
\subsubsection{Декодирование ССМП}

Декодер нужен для осуществления непосредственно перевода.
Он вычисляет величину
\[
	\arg\max\limits_{\cup \FE} \left(  P(\FE) \cdot P(\FR|\FE) \right)
\]
Задача декодирования является NP-полной \cite{Knight:1999}.
Существует несколько способов и методов декодирования.
Обычно выделяют:
\begin{itemize}
	\item полный перебор;
	\item поиск по первому наилучшему совпадению (A*):
	\begin{itemize}
		\item стековый поиск,
		\item мультистековый поиск;
	\end{itemize}
	\item жадный инкрементный поиск;
	\item сведение к обобщенной (асимметричной или симметричной) задаче коммивояжера:
	\begin{itemize}
		\item задача ЛП,
		\item метод Лина-Кернигана,
		\item генетические алгоритмы,
		\item {<<муравьиная оптимизация>>}.
	\end{itemize}
\end{itemize}
Каждый из методов обладает своими достоинствами и недостатками.
Вариант полного перебора мы рассматривать не будем, так как,
если мы ограничим наш поиск в строке не более чем 
в два раза длины $m$ строки исходного языка, 
то мы получим наивный метод c сложностью $O(m^2 v^{2m})$~\cite{Knight:1999}.

В данном случае можно рассмотреть только часть пространства возможных состояний.
При этом, скорее всего, мы можем пропустить самое хорошее решение, но сможем найти <<достаточно хорошее>>.
Для алгоритмов декодирования важными параметрами являются скорость, поиск ошибок, качество перевода.

\paragraph{Поиск по первому наилучшему совпадению}

Поиск учитывает как расстояние от начального состояния и оценки расстояния до цели.
В приложении декодирования имеем следующий алгоритм для стекового поиска:
\begin{enumerate}
	\item Инициализируем стек пустой гипотезой.
	\item Достаем лучшую гипотезу $h$ из стека.
	\item Если $h$ --- все предложение, выводим его и завершаем выполнение.
	\item Для всех возможных следующих слов $\WA$ расширить гипотезу $h$ и положить обратно в стек.
	\item Перейти ко второму шагу.	
\end{enumerate}
<<Стековым>> поиск назван по историческим причинам, 
на самом деле используется очередь с приоритетами.

Большим минусом этого поиска является, то что более короткие гипотезы имеют приоритет.
Мультистековый поиск отличается наличием отдельного <<для гипотез>> разного размера.
Крайне не экономичен по памяти. Для уменьшения пространства поиска возможны различные ухищрения,
основанные на знаниях о структуре предложения.

\pagebreak

\paragraph{Жадный инкрементный поиск}

Простой поиск, 
позволяет достичь решения путем выбора лучшей альтернативы, 
чтобы добраться до цели в настоящее время.
Эвристическая функция определяется как стоимость самого дешевого пути 
из текущего состояния в целевое состояние.
Жадный инкрементный поиск имеет следующие особенности:
\begin{itemize}
	\item {<<плохой>> вариант перевода получаем сразу};
	\item последовательно применяя набор операций можем улучшить перевод:
	\begin{itemize}	
		\item изменить перевод слова (группы слов),
		\item удалить слово (группу слов),
		\item поменять слова местами.
	\end{itemize} 
\end{itemize} 

В оригинальной работе \cite{Fast-Decoding:2003} приводится 
иной набор операций, но он относится исключительно к моделям высшего порядка (IBM 3-5).
Дело в том, что модели высших порядков учитывают наличие фертильности
слова --- величину показывающую сколько слов языка перевода 
способно породить данное слово исходного языка. 
C понятием фертильности связано понятие нулевого слова. 
Нулевое слова--- слово исходного языка не имеющее графического начертания в тексте,
и какого либо еще своего проявления, кроме того,
что оно обладает ненулевой фертильностью.
Кроме того, в классических 
моделях используется биграммная модель языка.
В связи с этим, к описанным выше опирается сразу добавляются
замены слов в зависимости от их фертильности,
вставки слов в какой либо участок между словами,
вставка слов и их одновременная замена.
В этой работе мы не вводим формальное описание моделей 
высших порядков, так как это займет достаточно внушительный объем.
Потому мы привели упрощенную версию алгоритма жадного поиска.
Именно такая версия поиска используется нами 
в~практической части работы.
Выносить отдельно описание мы тоже не стали,
так как ничем особенно новым этот вариант поиска не отличается.
Всего скорее такой алгоритм будет проходить по циклу операции быстрее 
оригинального, но этот факт требует дополнительных исследований 
и~количественных измерений.
В любом случае ясно, что за меньшее число операций придется платить
большим количеством итераций алгоритма.

Жадный поиск может стартовать из начального состояния, 
которое ни приведет к конечной цели.
Не является полным или оптимальным. 
Однако, это самый быстрый из существующих методов.
Жадный инкрементный поиск используется в данной работе.

\paragraph{Сведение к обобщенной задаче коммивояжера}

Исходными данными для задачи является множество вершин, 
разбиение этого множества на подмножества, 
и также матрица стоимостей перехода из одной вершины в другую. 
Задача заключается в нахождении кратчайшего замкнутого пути, 
который бы посетил по одной вершине в каждом подмножестве.

Если для двух смежных вершин $|\overarc{AB}| \ne |\overarc{BA}|$, то задача является асимметричной.
Для декодирования имеем:
\begin{itemize}	
	\item подмножество вершин --- слово исходного текста $\WR$;
	\item вершина --- вариант перевода $\WE$ (обычно выбирают 10 наиболее вероятных вариантов);
	\item расстояние --- величина неопределенности $-\log \left(  P(\FE) \cdot P(\FR|\FE) \right)$.
\end{itemize} 

Обобщенная задача коммивояжера (OЗК) сводится к простой задаче коммивояжера (ЗК) 
при помощи алгоритма Нуна-Бена \cite{Noon:1993}.
Далее ее решают средствами линейной оптимизации (крайне медленный вариант), 
эвристических алгоритмов, генетических алгоритмов, методов \emph{роевого} интеллекта.

Для данной работы сведения задачи декодирования к~обобщенной 
задаче коммивояжера практического значения не имеет,
но представляет особенной интерес 
в~рамках статистического машинного перевода.
В ходе исследований, сопутствующих работе нами был рассмотрен 
метод решения обобщенной задачи коммивояжера 
с помощью метода <<муравьиной оптимизации>>.
В результате, было сделано очень важное наблюдение --- 
для ЗК не важен город с~которого был начат обход графа,
а для задачи декодирования важен --- есть заданный порядок слов.

Метод <<муравьиной оптимизации>> как раз относился 
к таким не устойчивым методам. 
Относительный порядок слов (расположение $n$ соседних слов) 
может быть установлено с помощью модели целевого языка,
однако, например при циклическом сдвиге слов выходного предложения,
модель языка будет бессильна.

Сам по себе метод <<муравьиной оптимизации>> представляет 
из себя приближенный метод решения ЗК. 
Он основан на наблюдениях за поведением муравьев в природе.
Перемещаясь от одного пункта до другого, муравьи оставляют 
за собой тропы из феромонов
Если другие муравьи находят такие тропы, они, пойдут по ним. 
Тем самым укрепят воздействие феромонной тропы.
Со временем феромонная тропа испаряется. 
Чем больше времени требуется для прохождения, 
тем сильнее испарится феромонная тропа. 
Для ЗК муравьи сначала в случайном порядке выходят 
из каждого города, после заданного 
числа переходов отбирается путь который менее всего <<испарился>>.

В рамках задачи перевода при решении ЗК методом <<муравьиной оптимизации>> 
можно использовать на выходе циклический сдвиг полученных результатов,
но в это потребует дополнительных накладных расходов, которые могут перекрыть 
преимущества приближенного метода.

Можно также предложить вариант метода, когда каждый полученный результат
можно будет циклически сдвинуть на определенную величину 
и потом целиком проверить по модели языка, но в этом случае,
мы получим очередной и очень экзотический вариант жадного инкрементного поиска.


\pagebreak

